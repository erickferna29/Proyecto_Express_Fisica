<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ELECTRO GOLF: ULTIMATE</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        body { 
            margin: 0; overflow: hidden; 
            background: linear-gradient(135deg, #0a2f1f 0%, #1a472a 50%, #0f3520 100%);
            font-family: 'Orbitron', 'Segoe UI', sans-serif; 
            user-select: none; 
        }
        canvas { display: block; }
        
        /* UI PANEL MEJORADO */
        #ui {
            position: absolute; top: 20px; left: 20px; width: 240px;
            color: #fff; 
            background: linear-gradient(145deg, rgba(0,0,0,0.85), rgba(20,20,50,0.9)); 
            padding: 25px; border-radius: 20px; 
            border: 3px solid #00ffff;
            box-shadow: 0 0 30px rgba(0,255,255,0.5), inset 0 0 20px rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
        }
        
        h2 { 
            margin: 0 0 15px 0; 
            color: #00ffff; 
            font-size: 24px; 
            text-align: center; 
            text-transform: uppercase; 
            text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff;
            letter-spacing: 2px;
        }
        
        /* CONTROLES */
        .control-group { 
            margin-bottom: 20px; 
            background: rgba(0,0,0,0.3); 
            padding: 12px; 
            border-radius: 10px;
            border: 1px solid rgba(0,255,255,0.3);
        }
        label { 
            display: block; 
            font-weight: bold; 
            margin-bottom: 8px; 
            font-size: 14px; 
            color: #00ffff;
            text-shadow: 0 0 5px rgba(0,255,255,0.5);
        }
        
        /* SLIDER √âPICO */
        input[type=range] { 
            width: 100%; 
            cursor: pointer; 
            height: 8px;
            background: linear-gradient(90deg, #00ccff 0%, #ffff00 50%, #ff3333 100%);
            border-radius: 5px;
            outline: none;
            opacity: 0.9;
            transition: opacity 0.2s;
        }
        input[type=range]:hover { opacity: 1; }
        
        /* BOT√ìN REINTENTAR MEJORADO */
        #btnReset {
            width: 100%; padding: 12px; 
            background: linear-gradient(145deg, #ff3333, #cc0000);
            color: white;
            border: 2px solid #ff6666; 
            border-radius: 10px; 
            font-weight: 900; 
            font-size: 16px;
            cursor: pointer; 
            text-transform: uppercase; 
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(255,0,0,0.4);
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        #btnReset:hover { 
            background: linear-gradient(145deg, #ff0000, #990000);
            transform: translateY(-2px); 
            box-shadow: 0 7px 20px rgba(255,0,0,0.6);
        }
        #btnReset:active { 
            transform: translateY(1px); 
            box-shadow: 0 3px 10px rgba(255,0,0,0.4);
        }

        /* MENSAJES MEJORADOS */
        #debug { 
            position: absolute; 
            bottom: 15px; 
            left: 15px; 
            color: #00ff00; 
            font-family: 'Orbitron', monospace; 
            font-size: 14px; 
            pointer-events: none; 
            text-shadow: 0 0 10px #00ff00;
            background: rgba(0,0,0,0.7);
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid #00ff00;
        }
        
        .win-msg {
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%);
            color: #ffd700; 
            font-size: 80px; 
            font-weight: 900; 
            text-shadow: 0 0 20px #ffd700, 0 0 40px #ffd700, 4px 4px 0 #000;
            display: none; 
            text-align: center; 
            background: linear-gradient(145deg, rgba(0,0,0,0.95), rgba(20,20,50,0.95));
            padding: 50px; 
            border-radius: 25px; 
            border: 5px solid #ffd700; 
            z-index: 100;
            animation: pulse 1s infinite;
            box-shadow: 0 0 50px rgba(255,215,0,0.8);
        }
        
        @keyframes pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.05); }
        }
        
        /* ESTAD√çSTICAS */
        #stats {
            position: absolute;
            top: 20px;
            right: 20px;
            background: linear-gradient(145deg, rgba(0,0,0,0.85), rgba(20,20,50,0.9));
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #ffd700;
            color: #ffd700;
            font-family: 'Orbitron', sans-serif;
            box-shadow: 0 0 20px rgba(255,215,0,0.5);
            text-shadow: 0 0 5px rgba(255,215,0,0.5);
        }
        
        .stat-item {
            margin: 8px 0;
            font-size: 16px;
            font-weight: bold;
        }
    </style>
</head>
<body>

    <div id="ui">
        <h2>‚ö° CONTROL EL√âCTRICO</h2>
        
        <div class="control-group">
            <label>üîã CARGA: <span id="valCarga" style="color:#ff3333; font-size:18px;">+10</span> ¬µC</label>
            <input type="range" id="sliderCarga" min="-20" max="20" value="10" step="1">
            <div style="font-size:11px; color:#00ffff; text-align:center; margin-top:5px;">
                üìç <b>Rojo (+)</b>: Repele ROJOS, Atrae AZULES<br>
                üìç <b>Azul (-)</b>: Atrae ROJOS, Repele AZULES
            </div>
        </div>

        <button id="btnReset">üîÑ NUEVO NIVEL</button>
        
        <div style="margin-top:20px; font-size:12px; border-top:2px solid rgba(0,255,255,0.3); padding-top:15px; color:#00ffff;">
            <div style="text-align:center; margin-bottom:10px; font-weight:bold; font-size:14px;">üìã INSTRUCCIONES</div>
            <div style="line-height:1.6;">
            üéØ Click en la bola<br>
            üñ±Ô∏è Arrastra para apuntar<br>
            üöÄ Suelta para disparar<br>
            üí• <b>Dispara m√∫ltiples veces!</b><br>
            ‚å®Ô∏è Presiona <span style="color:#ffd700; font-weight:bold;">R</span> para reiniciar
            </div>
        </div>
    </div>

    <div id="stats">
        <div style="text-align:center; font-size:18px; margin-bottom:10px; border-bottom: 2px solid #ffd700; padding-bottom:8px;">üìä ESTAD√çSTICAS</div>
        <div class="stat-item">üéØ Tiros: <span id="statShots">0</span></div>
        <div class="stat-item">üèÜ Victorias: <span id="statWins">0</span></div>
        <div class="stat-item">‚ö° Mejor: <span id="statBest">--</span></div>
    </div>

    <div id="debug">üü¢ SISTEMA: LISTO PARA DISPARAR</div>
    <div id="winMsg" class="win-msg">
        üèÜ ¬°VICTORIA! üèÜ<br>
        <div style="font-size:30px; margin-top:20px;">Tiros: <span id="finalShots" style="color:#00ff00;">0</span></div>
        <button id="btnWinReset" style="font-size:22px; padding:15px 40px; margin-top:30px; cursor:pointer; background: linear-gradient(145deg, #00ff00, #00cc00); border:3px solid #00ff00; border-radius:15px; font-weight:900; box-shadow: 0 0 20px rgba(0,255,0,0.6); transition: 0.3s;">‚ñ∂Ô∏è SIGUIENTE NIVEL</button>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const debugDiv = document.getElementById('debug');
    
    // UI Elements
    const sliderCarga = document.getElementById('sliderCarga');
    const valCarga = document.getElementById('valCarga');
    const btnReset = document.getElementById('btnReset');
    const btnWinReset = document.getElementById('btnWinReset');
    const winMsg = document.getElementById('winMsg');
    const statShots = document.getElementById('statShots');
    const statWins = document.getElementById('statWins');
    const statBest = document.getElementById('statBest');
    const finalShots = document.getElementById('finalShots');

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // --- ESTAD√çSTICAS ---
    let stats = {
        shots: 0,
        wins: 0,
        bestScore: null
    };

    // --- F√çSICA ---
    const K = 18000;  // M√°s fuerza electromagn√©tica
    const DT = 0.016;  // 60 FPS
    const FRICTION = 0.994; // Menos fricci√≥n
    const MAX_POWER = 100; // POTENCIA BRUTAL
    const POWER_SENSITIVITY = 1.2; // MUY sensible
    const SHOT_DURATION = 5000; // 5 segundos antes de detenerse (en milisegundos)
    
    // Part√≠culas
    let particles = [];

    // Mapa - Inicializaci√≥n b√°sica
    let cx = canvas.width / 2;
    let cy = canvas.height / 2;
    let hole = { x: canvas.width * 0.85, y: cy, r: 25 };
    
    // Funci√≥n para generar obst√°culos aleatorios
    function generateRandomObstacles() {
        obstacles = [];
        const numObstacles = 3 + Math.floor(Math.random() * 2); // 3-4 obst√°culos
        
        for(let i = 0; i < numObstacles; i++) {
            const isPositive = Math.random() > 0.5;
            const x = cx + (Math.random() - 0.5) * (canvas.width * 0.5);
            const y = cy + (Math.random() - 0.5) * (canvas.height * 0.6);
            
            obstacles.push({
                x: Math.max(200, Math.min(canvas.width - 200, x)),
                y: Math.max(100, Math.min(canvas.height - 100, y)),
                q: isPositive ? (20 + Math.random() * 30) : -(20 + Math.random() * 30),
                r: 30 + Math.random() * 15,
                color: isPositive ? '#ff3333' : '#00ccff'
            });
        }
    }
    
    // Obst√°culos (Se generar√°n aleatoriamente)
    let obstacles = [];
    generateRandomObstacles();

    // Bola
    let ball = { 
        startX: 150, startY: cy,
        x: 150, y: cy, 
        vx: 0, vy: 0, 
        q: 10, r: 12, 
        moving: false,
        shotStartTime: 0 // Tiempo cuando se dispar√≥
    };
    
    // Funci√≥n para reposicionar elementos al cambiar tama√±o
    function repositionElements() {
        cx = canvas.width / 2;
        cy = canvas.height / 2;
        hole.x = canvas.width * 0.85;
        hole.y = cy;
        
        // Regenerar obst√°culos en nuevas posiciones aleatorias
        generateRandomObstacles();
        
        if(!ball.moving) {
            ball.startY = cy;
            ball.y = cy;
        }
    }

    // Mouse
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    let dragCurrent = { x: 0, y: 0 };

    // --- FUNCIONES UI ---
    
    // Actualizar carga desde el slider
    sliderCarga.addEventListener('input', (e) => {
        let val = parseInt(e.target.value);
        ball.q = val;
        
        // Actualizar texto y color
        valCarga.innerText = (val > 0 ? "+" : "") + val;
        // ROJO para positivo, AZUL para negativo
        valCarga.style.color = val > 0 ? "#ff3333" : "#00ccff";
        
        // Resetear visualmente si no se mueve
        if(!ball.moving) {
            draw();
        }
    });

    // Funci√≥n Reset
    function resetGame() {
        ball.x = ball.startX;
        ball.y = ball.startY;
        ball.vx = 0;
        ball.vy = 0;
        ball.moving = false;
        winMsg.style.display = 'none';
        particles = [];
        stats.shots = 0;
        statShots.innerText = stats.shots;
        
        // Generar nuevos obst√°culos aleatorios
        generateRandomObstacles();
        
        debugDiv.innerText = "üü¢ SISTEMA: NIVEL REINICIADO - NUEVOS OBST√ÅCULOS";
        draw();
    }

    btnReset.addEventListener('click', resetGame);
    btnWinReset.addEventListener('click', resetGame);

    // --- GAME LOOP ---
    function update() {
        // Actualizar part√≠culas
        particles = particles.filter(p => {
            p.life--;
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.2; // Gravedad
            p.alpha = p.life / p.maxLife;
            return p.life > 0;
        });

        if (ball.moving) {
            // Verificar si han pasado 5 segundos desde el disparo
            const elapsedTime = Date.now() - ball.shotStartTime;
            if (elapsedTime >= SHOT_DURATION) {
                ball.moving = false;
                ball.vx = 0;
                ball.vy = 0;
                debugDiv.innerText = "‚è±Ô∏è SISTEMA: TIEMPO AGOTADO - LISTA PARA DISPARAR";
                return;
            }
            
            let fx = 0, fy = 0;

            obstacles.forEach(obs => {
                let dx = ball.x - obs.x;
                let dy = ball.y - obs.y;
                let distSq = dx*dx + dy*dy;
                let dist = Math.sqrt(distSq);

                // Rebote Obst√°culos con efectos
                if (dist < obs.r + ball.r + 5) {
                    let angle = Math.atan2(dy, dx);
                    ball.vx = Math.cos(angle) * 15; 
                    ball.vy = Math.sin(angle) * 15;
                    ball.x += Math.cos(angle) * 8; 
                    ball.y += Math.sin(angle) * 8;
                    
                    // Generar part√≠culas en rebote
                    for(let i=0; i<15; i++) {
                        particles.push({
                            x: ball.x,
                            y: ball.y,
                            vx: (Math.random()-0.5)*8,
                            vy: (Math.random()-0.5)*8,
                            life: 30,
                            maxLife: 30,
                            color: obs.color,
                            alpha: 1
                        });
                    }
                }

                // Fuerza el√©ctrica solo a distancia
                if (dist > obs.r + ball.r + 10 && dist < 400) { 
                    // Ley de Coulomb: F = k * q1 * q2 / r¬≤
                    // Mismo signo (+,+ o -,-) ‚Üí F positiva ‚Üí REPULSI√ìN
                    // Signo opuesto (+,- o -,+) ‚Üí F negativa ‚Üí ATRACCI√ìN
                    let F = (K * ball.q * obs.q) / distSq;
                    
                    // dx/dy apuntan DESDE obst√°culo HACIA bola
                    // Si F > 0 (repulsi√≥n): empuja en direcci√≥n dx,dy (aleja)
                    // Si F < 0 (atracci√≥n): empuja en direcci√≥n -dx,-dy (acerca)
                    fx += F * (dx / dist);
                    fy += F * (dy / dist);
                }
            });

            ball.vx += fx * DT;
            ball.vy += fy * DT;
            
            // Limitar velocidad m√°xima
            let speed = Math.sqrt(ball.vx*ball.vx + ball.vy*ball.vy);
            if(speed > 120) { // VELOCIDAD M√ÅXIMA BRUTAL
                ball.vx = (ball.vx / speed) * 120;
                ball.vy = (ball.vy / speed) * 120;
            }
            
            ball.vx *= FRICTION; 
            ball.vy *= FRICTION;

            // Rastro de la bola (pelotitas blancas tipo golf)
            if(Math.random() < 0.2) {
                particles.push({
                    x: ball.x,
                    y: ball.y,
                    vx: 0,
                    vy: 0,
                    life: 15,
                    maxLife: 15,
                    color: '#ffffff',
                    alpha: 0.8
                });
            }

            if (Math.abs(ball.vx) < 0.05 && Math.abs(ball.vy) < 0.05) {
                ball.moving = false;
                ball.vx = 0;
                ball.vy = 0;
                debugDiv.innerText = "üü¢ SISTEMA: BOLA DETENIDA - LISTA PARA DISPARAR";
            }

            ball.x += ball.vx * DT;
            ball.y += ball.vy * DT;

            // Paredes
            if (ball.x < 0 || ball.x > canvas.width) ball.vx *= -0.8;
            if (ball.y < 0 || ball.y > canvas.height) ball.vy *= -0.8;
            ball.x = Math.max(ball.r, Math.min(canvas.width - ball.r, ball.x));
            ball.y = Math.max(ball.r, Math.min(canvas.height - ball.r, ball.y));

            // Win Condition
            let dxH = ball.x - hole.x;
            let dyH = ball.y - hole.y;
            if (Math.sqrt(dxH*dxH + dyH*dyH) < hole.r) {
                ball.moving = false;
                stats.wins++;
                statWins.innerText = stats.wins;
                
                if(stats.bestScore === null || stats.shots < stats.bestScore) {
                    stats.bestScore = stats.shots;
                    statBest.innerText = stats.bestScore;
                }
                
                finalShots.innerText = stats.shots;
                winMsg.style.display = 'block';
                
                // Generar nuevos obst√°culos para el siguiente nivel
                generateRandomObstacles();
                
                // Explosi√≥n de victoria tipo golf
                for(let i=0; i<80; i++) {
                    particles.push({
                        x: hole.x,
                        y: hole.y,
                        vx: (Math.random()-0.5)*20,
                        vy: (Math.random()-0.5)*20 - 5,
                        life: 80,
                        maxLife: 80,
                        color: ['#ffd700','#ffffff','#ff0000'][Math.floor(Math.random()*3)],
                        alpha: 1
                    });
                }
            }
        }
    }

    function draw() {
        // Fondo degradado animado
        const gradient = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, canvas.width);
        gradient.addColorStop(0, '#1a5f3a');
        gradient.addColorStop(0.5, '#2e8b57');
        gradient.addColorStop(1, '#0f3520');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Cuadricula brillante
        ctx.strokeStyle = 'rgba(0,255,255,0.15)';
        ctx.lineWidth = 1;
        for(let i=0; i<canvas.width; i+=50) { 
            ctx.beginPath(); 
            ctx.moveTo(i,0); 
            ctx.lineTo(i,canvas.height); 
            ctx.stroke(); 
        }
        for(let i=0; i<canvas.height; i+=50) { 
            ctx.beginPath(); 
            ctx.moveTo(0,i); 
            ctx.lineTo(canvas.width,i); 
            ctx.stroke(); 
        }

        // Part√≠culas
        particles.forEach(p => {
            ctx.globalAlpha = p.alpha * 0.8;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 3, 0, Math.PI*2);
            ctx.fill();
        });
        ctx.globalAlpha = 1;

        // Hoyo de golf realista
        ctx.save();
        
        // Sombra profunda del hoyo
        ctx.shadowColor = '#000';
        ctx.shadowBlur = 30;
        ctx.shadowOffsetY = 5;
        
        // Hoyo negro profundo
        ctx.beginPath(); 
        ctx.arc(hole.x, hole.y, hole.r, 0, Math.PI*2);
        ctx.fillStyle = '#000'; 
        ctx.fill();
        
        // Borde del c√©sped del hoyo
        ctx.strokeStyle = '#1a5f3a'; 
        ctx.lineWidth = 8; 
        ctx.stroke();
        
        // Bandera dentro del hoyo
        ctx.restore();
        
        // Asta de la bandera
        ctx.strokeStyle = '#888';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(hole.x, hole.y);
        ctx.lineTo(hole.x, hole.y - 50);
        ctx.stroke();
        
        // Bandera roja
        ctx.fillStyle = '#ff0000';
        ctx.beginPath();
        ctx.moveTo(hole.x, hole.y - 50);
        ctx.lineTo(hole.x + 25, hole.y - 40);
        ctx.lineTo(hole.x, hole.y - 30);
        ctx.closePath();
        ctx.fill();
        
        // Borde de la bandera
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 1;
        ctx.stroke();

        // Campos de fuerza y obst√°culos
        obstacles.forEach(obs => {
            // Campo de fuerza
            ctx.beginPath();
            ctx.arc(obs.x, obs.y, obs.r*2, 0, Math.PI*2);
            ctx.fillStyle = obs.color === '#ff3333' ? 'rgba(255,50,50,0.2)' : 'rgba(0,200,255,0.2)';
            ctx.fill();
            
            // Obst√°culo con brillo
            ctx.save();
            ctx.shadowColor = obs.color;
            ctx.shadowBlur = 20;
            ctx.beginPath(); 
            ctx.arc(obs.x, obs.y, obs.r, 0, Math.PI*2);
            ctx.fillStyle = obs.color; 
            ctx.fill();
            ctx.strokeStyle = '#000'; 
            ctx.lineWidth=2;
            ctx.stroke();
            ctx.restore();
            
            // S√≠mbolo de carga
            ctx.fillStyle = '#fff'; 
            ctx.font="bold 24px Arial"; 
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            // Mostrar el signo y valor aproximado
            let chargeVal = Math.abs(obs.q).toFixed(0);
            ctx.fillText(obs.q>0?"+":"‚àí", obs.x, obs.y);
            
            // Mostrar valor de carga peque√±o
            ctx.font="bold 12px Arial";
            ctx.fillText(chargeVal, obs.x, obs.y + 25);
        });

        // Bola de golf realista
        ctx.save();
        
        // Sombra de la bola
        ctx.shadowColor = 'rgba(0,0,0,0.5)';
        ctx.shadowBlur = 10;
        ctx.shadowOffsetX = 3;
        ctx.shadowOffsetY = 3;
        
        // Color seg√∫n carga: ROJO = positivo, AZUL = negativo
        const ballColor = ball.q > 0 ? '#ff3333' : '#00ccff';
        const glowColor = ball.q > 0 ? 'rgba(255,50,50,0.3)' : 'rgba(0,200,255,0.3)';
        
        // Aura el√©ctrica (m√°s visible cuando se mueve)
        if(ball.moving) {
            ctx.shadowColor = ballColor;
            ctx.shadowBlur = 25;
            ctx.beginPath(); 
            ctx.arc(ball.x, ball.y, ball.r*2, 0, Math.PI*2);
            ctx.fillStyle = glowColor;
            ctx.fill();
        }
        
        // Bola principal (blanca con patr√≥n de golf)
        ctx.shadowBlur = 5;
        ctx.beginPath(); 
        ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
        ctx.fillStyle = '#ffffff';
        ctx.fill();
        
        // Patr√≥n de hoyuelos de golf
        ctx.fillStyle = '#e0e0e0';
        for(let angle = 0; angle < Math.PI * 2; angle += Math.PI / 6) {
            for(let radius = 3; radius < ball.r; radius += 4) {
                const px = ball.x + Math.cos(angle) * radius;
                const py = ball.y + Math.sin(angle) * radius;
                ctx.beginPath();
                ctx.arc(px, py, 0.8, 0, Math.PI*2);
                ctx.fill();
            }
        }
        
        // Borde de la bola
        ctx.strokeStyle = '#ccc'; 
        ctx.lineWidth = 2;
        ctx.beginPath(); 
        ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
        ctx.stroke();
        
        // Indicador de carga en el centro
        ctx.shadowBlur = 0;
        ctx.fillStyle = ballColor;
        ctx.font = "bold 14px Arial";
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(ball.q > 0 ? "+" : "‚àí", ball.x, ball.y);
        
        // Timer visual cuando est√° en movimiento
        if(ball.moving) {
            const elapsedTime = Date.now() - ball.shotStartTime;
            const remainingTime = Math.max(0, SHOT_DURATION - elapsedTime);
            const seconds = (remainingTime / 1000).toFixed(1);
            
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(ball.x - 25, ball.y + 20, 50, 18);
            ctx.fillStyle = remainingTime < 2000 ? '#ff0000' : '#00ff00';
            ctx.font = 'bold 12px Arial';
            ctx.fillText(seconds + 's', ball.x, ball.y + 29);
        }
        
        ctx.restore();

        // Flecha de Tiro tipo golf con l√≠nea punteada
        if (isDragging) {
            let dx = dragStart.x - dragCurrent.x;
            let dy = dragStart.y - dragCurrent.y;
            let dist = Math.sqrt(dx*dx + dy*dy);
            let power = Math.min(dist * POWER_SENSITIVITY, MAX_POWER);
            
            const arrowColor = ball.q > 0 ? '#ff3333' : '#00ccff';
            
            ctx.save();
            
            // L√≠nea punteada de trayectoria
            ctx.setLineDash([10, 10]);
            ctx.beginPath();
            ctx.moveTo(ball.x, ball.y);
            let aimX = ball.x + dx * 2; 
            let aimY = ball.y + dy * 2;
            ctx.lineTo(aimX, aimY);
            ctx.lineWidth = 3;
            ctx.strokeStyle = arrowColor;
            ctx.globalAlpha = 0.6;
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Flecha s√≥lida direcci√≥n
            ctx.globalAlpha = 1;
            ctx.shadowColor = arrowColor;
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.moveTo(ball.x, ball.y);
            let shortX = ball.x + dx; 
            let shortY = ball.y + dy;
            ctx.lineTo(shortX, shortY);
            ctx.lineWidth = 6;
            ctx.strokeStyle = arrowColor;
            ctx.stroke();
            
            // Punta de flecha
            let angle = Math.atan2(dy, dx);
            ctx.beginPath();
            ctx.moveTo(shortX, shortY);
            ctx.lineTo(shortX - 20*Math.cos(angle-0.3), shortY - 20*Math.sin(angle-0.3));
            ctx.lineTo(shortX - 20*Math.cos(angle+0.3), shortY - 20*Math.sin(angle+0.3));
            ctx.closePath();
            ctx.fillStyle = arrowColor;
            ctx.fill();
            
            // Medidor de potencia estilo golf
            const meterWidth = 120;
            const meterHeight = 20;
            const meterX = ball.x - meterWidth/2;
            const meterY = ball.y - 50;
            
            // Fondo del medidor
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(meterX, meterY, meterWidth, meterHeight);
            
            // Barra de potencia con gradiente
            const powerPercent = power / MAX_POWER;
            const gradient = ctx.createLinearGradient(meterX, 0, meterX + meterWidth, 0);
            gradient.addColorStop(0, '#00ff00');
            gradient.addColorStop(0.5, '#ffff00');
            gradient.addColorStop(1, '#ff0000');
            ctx.fillStyle = gradient;
            ctx.fillRect(meterX + 2, meterY + 2, (meterWidth - 4) * powerPercent, meterHeight - 4);
            
            // Borde del medidor
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.strokeRect(meterX, meterY, meterWidth, meterHeight);
            
            // Texto de potencia
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`${Math.round(powerPercent * 100)}%`, ball.x, meterY - 8);
            
            ctx.restore();
        }
    }

    function loop() { 
        update(); 
        draw(); 
        requestAnimationFrame(loop);
    }

    // --- EVENTOS MOUSE ---
    canvas.addEventListener('mousedown', e => {
        // QUITAMOS LA RESTRICCI√ìN - Ahora puedes disparar siempre
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        let dx = mouseX - ball.x;
        let dy = mouseY - ball.y;
        
        // Detectar click en bola (o cerca)
        if (Math.sqrt(dx*dx + dy*dy) < 80) { 
            isDragging = true;
            dragStart = { x: mouseX, y: mouseY };
            dragCurrent = { x: mouseX, y: mouseY };
            debugDiv.innerText = "üîµ SISTEMA: APUNTANDO... ARRASTRA Y SUELTA";
        }
    });

    canvas.addEventListener('mousemove', e => {
        if (isDragging) {
            const rect = canvas.getBoundingClientRect();
            dragCurrent = { 
                x: e.clientX - rect.left, 
                y: e.clientY - rect.top 
            };
        }
    });

    canvas.addEventListener('mouseup', e => {
        if (!isDragging) return;
        isDragging = false;
        
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        let dx = dragStart.x - mouseX;
        let dy = dragStart.y - mouseY;
        let dist = Math.sqrt(dx*dx + dy*dy);
        let power = Math.min(dist * POWER_SENSITIVITY, MAX_POWER);
        let angle = Math.atan2(dy, dx);

        if (dist > 10) {
            // Sumar velocidad al disparo existente (no reemplazar)
            ball.vx += Math.cos(angle) * power;
            ball.vy += Math.sin(angle) * power;
            ball.moving = true;
            ball.shotStartTime = Date.now(); // Registrar tiempo de disparo
            stats.shots++;
            statShots.innerText = stats.shots;
            debugDiv.innerText = "üî¥ SISTEMA: ¬°DISPARO EJECUTADO! üí•";
        } else {
            debugDiv.innerText = "‚ö†Ô∏è SISTEMA: TIRO CANCELADO (MUY CORTO)";
        }
    });
    
    // Tecla R
    window.addEventListener('keydown', e => {
        if(e.key.toLowerCase() === 'r') resetGame();
    });

    // Ajustar canvas al redimensionar
    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        repositionElements();
    });

    // Iniciar juego
    repositionElements();
    loop();

</script>
</body>
</html>